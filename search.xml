<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[公众号推荐]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[阿里技术公众号介绍 阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。 如官方介绍所说，会推送一些阿里用到的技术。也整理出一系列的 pdf 出来给大家。 美团点评技术团队公众号介绍 这里是美团点评强大技术团队的对外窗口，每周腿送一线实践技术文章、技术活动、技术招聘信息。 会覆盖前端、后端、算法等等，也会推送一些技术沙龙活动。该技术团队除了这个公众号另外还维护一个技术博客，https://tech.meituan.com/。 淘宝技术公众号介绍 淘宝技术官方账号。 后端、前端、机器学习，总之淘宝用到的技术，都有机会在这里领略到。 WeMobileDev公众号介绍 微信移动客户端开发团队官号，分享微信在Android、iOS、Mac、Winphone、Windows等平台的开发经验、前沿技术，以及一些鲜为人知的小故事。 因为WCDB关注的该公众号，介绍的皆是微信在开发过程中遇到的问题解决方案，还有开源框架介绍。 移动开发前线公众号介绍 专注于分享移动开发前沿和一线技术。 主要推送一些关于移动端和前端的一些精选文章，两端技术、RN等等。也会推送一些关于移动端的热点文章，Kotlin、Swift、小程序等等。 聊聊架构公众号介绍 以架构之“道”为基础，呈现更多务实落地的架构内容。 主要推送一些关于架构设计的文章，包括前端后端，文章质量还是蛮高的。 云栖社区公众号介绍 云栖社区是由阿里云负责运营、阿里巴巴技术协会和阿里巴巴集团各技术团队提供内容支持的开放式技术社区。 有时候会和几个阿里系的公众号发同样的文章，主要还是会发一些热点知识，人工智能、区块链、服务端架构等待。 InfoQ公众号介绍 有内容的技术社区媒体。 在这里除了技术干货，还能学到如何定位自身。作为一个技术，你不仅需要掌握技术，还需要扩充横向知识面，为你的人生铺路。 stromzhang公众号介绍 一名不羁的码农，我的世界不只有 Coding！ 最后推荐的是一个个人运营的公众号，刚开始是以为 Android 开发者，写一下关于 Android 开发的文章，后来会涉及一些管理的文章。现在已经没有限制了，包括广告，总的来说质量还可以吧。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift关于!和?的Tip]]></title>
    <url>%2F2018%2F02%2F06%2FSwift%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%8C%85%E7%9A%84Tip%2F</url>
    <content type="text"><![CDATA[前言 Q: 为什么我现在还在写这些入门级别的语法 Tip 呢？ A: 因为我现在才开始学习 Swift 呗~ Q: 为什么我现在才开始学习 Swift 呢？ A: 因为懒呗~ 哈哈~分享一些自己看到的小 Tip 给大家，让那些也才入门 Swift 的童鞋也能多了解一些~ 关于 ! 和 ?今天这里不打算介绍为什么 Swift 里面会有 ! 和 ?，有什么不明白的可以看看这里：Swift中 ！和 ？的区别及使用 现在我们看一个平时用到的例子： 1234let width: Int? = 3var area: Int? area = width! * width! 为什么这里 let area = width! * width! 会有这么多的 ! 呢？因为机（愚）智（蠢）的 Xcode 建议我们这样写。最关键的是如果 width 真的就是 nil 会这么样呢？机智如你，会 Crash。 那保险一点的写法应该是这样子的： 123456789let width: Int? = 3var area: Int?if let tmp = width &#123; area = tmp * tmp&#125;else &#123; area = nil&#125; 完全不符合 Swift 作为一门优雅的语言的称号。 Optional Map面对上面的问题，有个很优雅的写法，那就是 Optional Map。让我们先看一下 Optional 中关于 map 的声明。 123public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123; public func map&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U) rethrows -&gt; U?&#125; 该方法的作用是，如果输入有值，则进入 transform 的闭包进行变化，并返回一个 U? ;如果输入就是 nil 的话，则直接返回 nil 的 U?。 那么我们就有如下优雅的写法了： 1234let width: Int? = 3let area = width.map &#123; $0 * $0&#125; 更多我们还能在 Collection 中看到 map 的身影。 123456789101112131415161718192021extension Collection &#123; /// Returns an array containing the results of mapping the given closure /// over the sequence&apos;s elements. /// /// In this example, `map` is used first to convert the names in the array /// to lowercase strings and then to count their characters. /// /// let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;] /// let lowercaseNames = cast.map &#123; $0.lowercaseString &#125; /// // &apos;lowercaseNames&apos; == [&quot;vivien&quot;, &quot;marlon&quot;, &quot;kim&quot;, &quot;karl&quot;] /// let letterCounts = cast.map &#123; $0.count &#125; /// // &apos;letterCounts&apos; == [6, 6, 3, 4] /// /// - Parameter transform: A mapping closure. `transform` accepts an /// element of this sequence as its parameter and returns a transformed /// value of the same or of a different type. /// - Returns: An array containing the transformed elements of this /// sequence. public func map&lt;T&gt;(_ transform: (Self.Element) throws -&gt; T) rethrows -&gt; [T]&#125; 注释的很清楚了，就不多介绍了。值得注意的是 Collection 本身是一个 protocol，所以所有实现了 Collection 协议的都有这个方法。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github源码索引]]></title>
    <url>%2F2018%2F01%2F27%2FGithub%E6%BA%90%E7%A0%81%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[一、UI相关 NotificationBanner 通知栏提醒 DKImagePickerController 系统相册 SwipeCellKit 系统邮箱手势的Cell JTCalendar 日历 CVCalendar 日历 XLForm 表单系统 Eureka 表单系统二、Extension SwifterSwift三、工具 SwiftyJSON JSON转Model四、其他 英语进阶指南 12306ForMac 12306 订票/捡票 助手 跳一跳辅助 答题App辅助]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github源码推荐(1.22~1.28)]]></title>
    <url>%2F2018%2F01%2F27%2FGithub%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.22-1.28)%2F</url>
    <content type="text"><![CDATA[除了推荐一些源码，如果遇到其他相关我也会推荐给大家，排名来自于心情。 一、英语进阶指南夫人最近也在学习英语，不知道这个对她是否有用呢？ 英语作为一门语言，学习起来应该是一件比较自然而然的事情，就像我们自然而然地学会汉语那样。 效果图 热度1Star: 7800+ Github主页https://github.com/byoungd/English-level-up-tips-for-Chinese 二、春节即将来临，是否有小伙伴再开始抢票了呢？如果你使用的是Mac系统，那就试试这个吧，专为Mac OS打造的12306 订票/捡票 助手。效果图 热度1Star: 2000+ Github主页https://github.com/fancymax/12306ForMac 三、习惯了OC下的YYModel等Dictionary转Model工具，在Swift下是否不适应呢？试试SwiftyJSON吧，一定会为你带来更好的体验。热度1Star: 16000+ CocoaPods1pod &apos;SwiftyJSON&apos; Carthage1github &quot;SwiftyJSON/SwiftyJSON&quot; Github主页https://github.com/SwiftyJSON/SwiftyJSON 四、是否厌倦了Toast一成不变的样式呢？你可以试试NotificationBanner，漂亮的动画样式，新颖的交互体验。效果图 热度1Star: 1700+ CocoaPods1pod &apos;NotificationBannerSwift&apos; Carthage1github &quot;Daltron/NotificationBanner&quot; &quot;master&quot; Github主页https://github.com/Daltron/NotificationBanner 好了，暂时就推荐这么多给大家，下周我们再见。 PS：本文中图片部分皆来自于作者Github主页，如有侵权，请告知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github源码推荐(1.15~1.21)]]></title>
    <url>%2F2018%2F01%2F21%2FGithub%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.15~1.21)%2F</url>
    <content type="text"><![CDATA[大家好，一周时间过得真快，本次主题依旧，推荐一些Github上的源码，排名不分先后。 一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。 特点 使用手机模拟器，快速识别~ 浏览器自动搜索显示结果，搜索引擎可配置，结果一目了然~ 模拟器还能多开哦~全部答对奖金翻倍，遇到不会的可以多选乱蒙 万英雄/知识超人/冲顶大会都支持哦~ 效果图 热度1Star: 800+ Github主页https://github.com/rrdssfgcs/wenda-helper 二、上一周给大家推荐了一个Objective-C的日历，这次给大家推荐一个Swift4的日历控件，作者写的非常好棒，支持Storyboard。效果图 热度1Star: 2800+ CocoaPods1pod &apos;CVCalendar&apos;, &apos;~&gt; 1.6.0&apos; Github主页https://github.com/CVCalendar/CVCalendar 三、使用Swift的时候是不是需要写好多的Extension呢？使用这个开源库后就再也不用劳心劳力的写很多的Extension了。 SwifterSwift is a collection of over 500 native Swift extensions, with handy methods, syntactic sugar, and performance improvements for wide range of primitive data types, UIKit and Cocoa classes –over 500 in 1– for iOS, macOS, tvOS and watchOS. 简直不要太强大，而且支持Swift4。 热度1Star: 4200+ CocoaPods1pod &apos;SwifterSwift&apos; 你也可以只集成部分Extension，例如1pod &apos;SwifterSwift/Foundation&apos; 具体还是去作者主页看吧。 Carthage1github &quot;SwifterSwift/SwifterSwift&quot; ~&gt; 4.0 Github主页https://github.com/SwifterSwift/SwifterSwift 四、基本上所有的App都逃脱不了表单，设置、用户界面等待，都是一些枯燥无味的代码，却又要花费时间、精力去自定义每个Cell达到各式各样的效果，此次为大家推荐一个强大的表单开源库，最重要的是OC和Swift都有，各取所需。 OC版 效果图 热度1Star: 4800+ CocoaPods1pod &apos;XLForm&apos;, &apos;~&gt; 4.0&apos; Carthage1github &quot;xmartlabs/XLForm&quot; ~&gt; 4.0 Github主页https://github.com/xmartlabs/XLForm Swift版 效果图 热度1Star: 7500+ CocoaPods1pod &apos;Eureka&apos; Carthage1github &quot;xmartlabs/Eureka&quot; ~&gt; 4.0 Github主页https://github.com/xmartlabs/Eureka 关于使用方法这里就不再介绍了，项目主页上介绍的非常清楚，有需求的小伙伴就自己去查看吧~ 好了，暂时就推荐这么多给大家，下周我们再见。 PS：本文中图片部分皆来自于作者Github主页，如有侵权，请告知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github源码推荐(1.8~1.14)]]></title>
    <url>%2F2018%2F01%2F14%2FGithub%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.8~1.14)%2F</url>
    <content type="text"><![CDATA[本次给大家推荐一些Github上的源码，排名不分先后。 一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。原理说明(摘自作者原文) 将手机点击到《跳一跳》小程序界面 用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来 计算按压时间 手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离； 自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘； 用 ADB 工具点击屏幕蓄力一跳 热度1Star: 11800+ Github主页https://github.com/wangshub/wechat_jump_game 二、是否觉得系统的相册太不方便，而自定义又太耗费时间，那就试试DKImagePickerController吧，作者完全使用Swift编写，支持CocoaPods。效果图 热度1Star: 890+ CocoaPods1pod &apos;DKImagePickerController&apos; Github主页https://github.com/zhangao0086/DKImagePickerController 三、系统邮箱中的交互让很多人大爱，尤其是列表的左右滑动手势，Github上有很多人都开源了自己的模仿源码，本次推荐的也是一个使用纯Swift编写的源码。效果图 热度1Star: 2700+ CocoaPods1pod &apos;SwipeCellKit&apos; Carthage1github &quot;SwipeCellKit/SwipeCellKit&quot; Github主页https://github.com/SwipeCellKit/SwipeCellKit 四、相信很多人都有编写日历的需求，在Todo，万年历等中，都需要日历，本次为大家推荐一个Objective-C编写的日历，支持横向和纵向滚动，支持切换月视图和周视图，支持Localization。效果图 热度1Star: 2400+ CocoaPods1pod &apos;JTCalendar&apos;, &apos;~&gt; 2.0&apos; Carthage1github &quot;jonathantribouharet/JTCalendar&quot; ~&gt; 2.2 Github主页https://github.com/jonathantribouharet/JTCalendar 好了，暂时就推荐这么多给大家，下周我们再见。 PS：本文中图片部分皆来自于作者Github主页，如有侵权，请告知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods设置target支持的swift版本]]></title>
    <url>%2F2017%2F11%2F24%2FCocoaPods%E8%AE%BE%E7%BD%AEtarget%E6%94%AF%E6%8C%81%E7%9A%84swift%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[上一篇文章说道在Swift4.0中如何引用3.0版本的第三方库，详见这篇文章。但是如果Pods中有很多第三方库都只支持3.0，一个一个修改恐怕是要累死。而且每次执行pod update之后之前设置的都会被重置，恐怕是想死的心都有了。有一句是说：”懒惰”推动了人类的进步。所以程序猿总是有办法的。 Talk is cheap, Show me the code1234567891011121314151617platform :ios, &apos;10.0&apos;use_frameworks!target &apos;YourTarget&apos; do pod &apos;SnapKit&apos;, &apos;~&gt; 4.0.0&apos; pod &apos;Toast-Swift&apos;, &apos;~&gt; 2.0.0&apos;endpost_install do |installer| installer.pods_project.targets.each do |target| if target.name == &apos;Toast-Swift&apos; target.build_configurations.each do |config| config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.2&apos; end end endend]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift4</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode9下自动化编译错误]]></title>
    <url>%2F2017%2F11%2F09%2FXcode9%E4%B8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[最近在使用CI平台打包时突然失败了，查看日志后发现是在exportArchive时失败了。之前一直都是好好地，升级了Xcode之后突然就不行了，提示如下信息：123error: exportArchive: &quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.Error Domain=IDEProvisioningErrorDomain Code=9&quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.&quot; UserInfo=&#123;NSLocalizedDescription=&quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features., NSLocalizedRecoverySuggestion=Add a profile to the &quot;provisioningProfiles&quot; dictionary in your Export Options property list.&#125; 查阅资料后发现，在Xcode9下，xcodebuild需要配置更多的信息才能导出ipa，最主要的一个就是provisioningProfiles。具体的操作步骤如下。 使用Xcode Archive一个新的版本 在Organizer中找到刚刚Archive出来的版本，选择Export。 选择你要导出的ipa类型，如果你需要不同版本，可以重复该流程，就可以得到其他类型所需要的信息了。 导出ipa到目录 最终导出的目录下会有4个文件，除了ipa文件还有一个ExportOptions.plist文件，这个文件就是我们使用xcodebuild -exportArchive命令时，-exportOptionsPlist参数需要指定的plist文件。 我们用这个新的plist文件就可以了。如果你需要打其他类型的ipa，可以重复上述步骤，在第三步重新选择即可。你也可以按照刚才导出的plist自己修改。 新的plist中有如下一些选项，你也可以参照修改。12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;ad-hoc&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.tsing.calculate&lt;/key&gt; &lt;string&gt;calculate_adhoc&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;signingCertificate&lt;/key&gt; &lt;string&gt;iPhone Distribution&lt;/string&gt; &lt;key&gt;signingStyle&lt;/key&gt; &lt;string&gt;manual&lt;/string&gt; &lt;key&gt;stripSwiftSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;CL32FD34&lt;/string&gt; &lt;key&gt;thinning&lt;/key&gt; &lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>自动打包</tag>
        <tag>xcodebuild</tag>
        <tag>Jenkins</tag>
        <tag>Xcode9</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.0引用3.0第三方库]]></title>
    <url>%2F2017%2F10%2F21%2FSwift4.0%E5%BC%95%E7%94%A83.0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Swift已经发布了4.0版本，在Xcode9中新建项目后，默认是使用4.0语法的。项目中的引用的第三方库，虽然有很多已经发不了4.0版本，但是还是有一些未及时更新的，那在作者未更新之前我们是否有更好的办法来使用这些第三方库呢？答案当然是肯定的，Xcode9中是同时支持3.2和4.0语法的。具体的设置可以看下图。 那么下面就说说如何设置同时支持3.2和4.0。 项目中如果使用Cocoapods来管理第三方库时，可以找到不支持4.0语法的库所在target，然后找到Swift Language Version选项，改为3.2，然后就可以顺利编译通过了。 如果还有以源码集成进项目的，那就选择Edit &gt; Convert &gt; To Current Swift Syntax..吧]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift4</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS下更改系统音量]]></title>
    <url>%2F2017%2F09%2F30%2FiOS%E4%B8%8B%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E9%9F%B3%E9%87%8F%2F</url>
    <content type="text"><![CDATA[iOS中，如果想更改系统音量，只有2个方法，一是使用私有方法；二是使用MPVolumeView。 私有方法不在我们的讨论范围之列，我们来讨论一下如何使用MPVolumeView。 用过一系列的音乐播放器都知道，添加一个MPVolumeView在View上，然后设置showsVolumeSlider = YES，就会有一个SliderView，用户滑动时，就能更改系统音量。 这样带来的问题就是， 会显示一个MPVolumeView; 需要手动触发滑动事件; 对于第一个问题很简单，MPVolumeView的hidden属性设置为YES即可；所以主要解决如何模拟用户手动滑动事件即可。 不多说，有了思路后就变得很简单了，下面奉上实现代码。 12345678910111213141516171819202122232425262728293031323334/* * 设置音量 */- (void)setVolume:(float)value &#123; UISlider *volumeSlider = [self volumeSlider]; self.volumeView.showsVolumeSlider = YES; // 需要设置 showsVolumeSlider 为 YES // 下面两句代码是关键 [volumeSlider setValue:value animated:NO]; [volumeSlider sendActionsForControlEvents:UIControlEventTouchUpInside]; [self.volumeView sizeToFit];&#125;- (MPVolumeView *)volumeView &#123; if (!_volumeView) &#123; _volumeView = [[MPVolumeView alloc] init]; _volumeView.hidden = YES; [self.window addSubview:_volumeView]; &#125; return _volumeView;&#125;/* * 遍历控件，拿到UISlider */- (UISlider *)volumeSlider &#123; UISlider* volumeSlider = nil; for (UIView *view in [self.volumeView subviews]) &#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123; volumeSlider = (UISlider *)view; break; &#125; &#125; return volumeSlider;&#125;]]></content>
      <categories>
        <category>小飞鱼</category>
      </categories>
      <tags>
        <tag>音量</tag>
        <tag>MPVolumeView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS拨打电话对话框问题解决]]></title>
    <url>%2F2017%2F09%2F28%2FiOS%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D%E5%AF%B9%E8%AF%9D%E6%A1%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[iOS中拨打电话大家应该都很清楚了，如果还有什么疑问的话可以参考这篇文章。但是iOS10的系统会先有个对话框确认，这与并不符合小飞鱼的需求。小飞鱼是由语音控制拨打电话，当用户查找到号码后，只需语音确认一次即可拨打电话，如果有系统的确认对话框，不仅多了一个步骤，而且还需要模拟点击对话框按钮事件，比较繁琐。由于小飞鱼中，App和设备之间是通过BLE和传统蓝牙来连接的，而用过蓝牙耳机的都应该知道，可以之间通过蓝牙耳机拨打电话。所以方案就有了：如上图，App端先通过BLE把号码发送给设备，然后设备通过传统蓝牙协议(PBAP中AT Command)，直接拨号即可，不会弹出确认框。 具体的指令如下：AT#CW13012341234\r\n；整个PBAP协议参见这篇文章]]></content>
      <categories>
        <category>小飞鱼</category>
      </categories>
      <tags>
        <tag>打电话</tag>
        <tag>蓝牙</tag>
        <tag>PBAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小飞鱼项目有感]]></title>
    <url>%2F2017%2F09%2F27%2F%E5%B0%8F%E9%A3%9E%E9%B1%BC%E9%A1%B9%E7%9B%AE%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[小飞鱼是科大讯飞车载开发的一款智能行车助手，通过语音操作，让你在开车过程中解放双手，使你在开车过程中更加安全，体验更优。小飞鱼目前支持使用语音导航，打电话，听音乐、节目、电台，查询天气、股票，还支持对话闲聊，让你的旅途不再寂寞。 整个项目涉及蓝牙、BLE、电话、高德导航以及媒体播放，在项目过程中遇到很多坑，后续会逐步介绍项目中遇到的问题。这里先在这里打个广告吧（微信文章直接长按识别二维码，或者可以点击底部阅读原文）。iOS App下载地址 设备购买地址 1. iOS拨打电话对话框问题解决]]></content>
      <categories>
        <category>小飞鱼</category>
      </categories>
      <tags>
        <tag>电话</tag>
        <tag>小飞鱼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS下日志记录]]></title>
    <url>%2F2017%2F09%2F24%2FiOS%E4%B8%8B%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[iOS开发中，一般大家都会自定义一个DLog的宏来代替NSLog，用来控制Release下的Log输出。但是有以下几个弊端： 没有日志分级。做过Android的都知道，Android可以分为5级，Error、Warning、Info、Debug、Verbose。 日志没法记录到文件，Release版本无法通过Log日志定位问题。 所以今天就推荐一个第三方库，CocoaLumberjack，完全满足以上需求，不但如此，还支持以下需求： 自定义Log文件的文件数、有效期、缓存大小123fileLogger.logFileManager.maximumNumberOfLogFiles = 20;fileLogger.maximumFileSize = 1024 * 1024 * 5;fileLogger.rollingFrequency = 60 * 60 * 24; 具体使用大家还是看看GitHub上的介绍。现在说一下集成中遇到的问题：1 . 可以自定义输出Log的格式，需要实现DDLogFormatter协议，下面提供一个示例：123456789101112131415161718192021222324- (NSString *)formatLogMessage:(DDLogMessage *)logMessage &#123; NSString *logLevel = nil; switch (logMessage.flag) &#123; case DDLogFlagError: logLevel = @&quot;[E]&quot;; break; case DDLogFlagWarning: logLevel = @&quot;[W]&quot;; break; case DDLogFlagInfo: logLevel = @&quot;[I]&quot;; break; case DDLogFlagDebug: logLevel = @&quot;[D]&quot;; break; default: logLevel = @&quot;[V]&quot;; break; &#125; NSString *formatString = [NSString stringWithFormat:@&quot;%@ %@ [@%zd] %@ %@&quot;, [logMessage.timestamp descriptionWithLocale:[NSLocale currentLocale]], logLevel, logMessage.line, logMessage.function, logMessage.message]; return formatString;&#125; 2 . 在单步调试时会发现，很多级别的日志不会立即显示到控制台中。在DDLogMacros.h中，我们可以看到以下几个宏定义：12345#define DDLogError(frmt, ...) LOG_MAYBE(NO, LOG_LEVEL_DEF, DDLogFlagError, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)#define DDLogWarn(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagWarning, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)#define DDLogInfo(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagInfo, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)#define DDLogDebug(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagDebug, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)#define DDLogVerbose(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagVerbose, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__) 你会发现DDLogError和其他的宏定义的第一个参数不是很一样，然后找到LOG_ASYNC_ENABLED的定义，这样就很明白了，如果你需要立即显示，把LOG_ASYNC_ENABLED的定义改为如下即可。123#ifndef LOG_ASYNC_ENABLED #define LOG_ASYNC_ENABLED NO#endif 3 . 说一下rollingFrequency这个属性，看了源码后发现，作者是根据文件的创建时间来处理的，所以就会导致这样的问题，1号15:00创建的文件，然后用到2号15:00就会重新创建一个文件，所以会导致2号的Log在15:00被分为2个文件。 如果需要更高度的自定义，可以去CocoaLumberjack主页上看一下README。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源协议知多少]]></title>
    <url>%2F2016%2F12%2F30%2F%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9F%A5%E5%A4%9A%E5%B0%91%2F</url>
    <content type="text"><![CDATA[越来越多的公司和个人在GitHub上开源他的代码，这是一种精神。为那些开源的公司和个人致敬、点赞。当你在GitHub上创建一个项目的时候，就会让你选择一个License，像MIT，BSD，GPL v2等等。但是这么多开源协议，你真的知道怎么选择吗？当你用到一个开源库的时候，你真的看清他的开源协议吗？或许，目前来说，你并没有注意到这些。但是，随着国内对知识产权的越来越重视（从音乐就可窥见一斑），说不定哪一天你就会收到一封邮件。好吧，说了这么多，我们还是用一张图来读懂那些开源协议吧。乌克兰程序员 Paul Bagwell 画了一张分析图（下图为阮一峰汉化版）。 图片来自文章别以为把你的代码上传到开源中国就算是开源了！先选择一个合适的 License 吧。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 高性能异构滚动视图-LazyScrollView实现]]></title>
    <url>%2F2016%2F12%2F08%2FiOS-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BC%82%E6%9E%84%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE-LazyScrollView%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[LazyScrollView简介 LazyScrollView 继承自ScrollView，目标是解决异构（与TableView的同构对比）滚动视图的复用回收问题。它可以支持跨View层的复用，用易用方式来生成一个高性能的滚动视图。此方案最先在天猫iOS客户端的首页落地。 —-苹果核 - iOS 高性能异构滚动视图构建方案 —— LazyScrollView 在这篇文章中，博主详细介绍了LazyScrollView的使用和实现方案，但是并没有给出具体DEMO，这里只是站在巨人的肩膀上，给一个DEMO，同时也希望可以抛砖引玉。 LazyScrollView使用暂时的实现比较简陋，目前只有一个id&lt;LazyScrollViewDataSource&gt; dataSource;，需要实现下面三个接口：123456789@protocol LazyScrollViewDataSource &lt;NSObject&gt;@required// ScrollView一共展示多少个item- (NSUInteger)numberOfItemInScrollView:(LazyScrollView *)scrollView;// 要求根据index直接返回RectModel- (LSVRectModel *)scrollView:(LazyScrollView *)scrollView rectModelAtIndex:(NSUInteger)index;// 返回下标所对应的view- (UIView *)scrollView:(LazyScrollView *)scrollView itemByLsvId:(NSString *)lsvId;@end 其中LSVRectModel就是原文中的TMMuiRectModel：1234567@interface LSVRectModel : NSObject// 转换后的绝对值rect@property (nonatomic, assign) CGRect absRect;// 业务下标@property (nonatomic, copy) NSString *lsvId;+ (instancetype)modelWithRect:(CGRect)rect lsvId:(NSString *)lsvId;@end 三个接口都很简单，和UITableView很类似，如果有不清楚，可以在底部查看DEMO或者原文。 另外，LazyScrollView提供了三个接口，也都是仿照UITableView来的，所以整个LazyScrollView的使用应该是很容易上手的：123- (void)reloadData;- (UIView *)dequeueReusableItemWithIdentifier:(NSString *)identifier;- (void)registerClass:(Class)viewClass forViewReuseIdentifier:(NSString *)identifier; LazyScrollView实现最主要的思路就是复用，所以有两个View池：12@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, NSMutableSet *&gt; *reuseViews;@property (nonatomic, strong) NSMutableSet&lt;__kindof UIView *&gt; *visibleViews; 由于每个View可能对应不同的identifier，所以reuseViews是一个NSMutableDictionary。当一个View滑出可见区域之后，会将它先从visibleViews中移除，然后添加到reuseViews中，并从LazyScrollView中 remove，即调用removeFromSuperview。这个地方在原文中作者的表述可能让大家误会了。 LazyScrollView中有一个Dictionary，key是reuseIdentifier,Value是对应reuseIdentifier被回收的View，当LazyScrollView得知这个View不该再出现了，会把View放在这里，并且把这个View hidden掉。 这里作者用的是hidden掉，但是我们知道，hidden只是控制显隐，View本身还是在那里，也无法去复用。 而当一个View滑到可见区域内时，需要先从reuseViews中复用，如果reuseViews没有，则重新创建一个。相关实现请看- (UIView *)dequeueReusableItemWithIdentifier:(NSString *)identifier;。 最后一个问题就是如何判断一个View是在可见区域内的。这里原文中说的很清晰，还有图片配合。建议大家还是移步原文。这里我简单说一下，找到顶边大于contentOffset.y - BUFFER_HEIGHT，底边小于contentOffset.y+CGRectGetHeight(self.bounds) + BUFFER_HEIGHT，然后两个集合取交集就是需要显示的View集合了。当然，这里有一些处理算法： 对 顶边 做升序处理得到一个集合，对 底边 降序处理得到一个集合。 采用二分法查找合适的位置，然后再对上一步得到的集合取子集即可。 好了，说了这么多，先放出DEMO地址吧，希望大家可以帮助完善，也希望可以给个Star。https://github.com/HistoryZhang/LazyScrollView。原文地址：苹果核 - iOS 高性能异构滚动视图构建方案 —— LazyScrollView（里面还有很多干货）。 最后说一下目前写的几个问题，希望大家可以一起来优化： 没有处理View点击事件，即没有写delegate回调。 二分法查找合适位置的时候算法待优化。 从旧的visibleViews中移除被滑出的View算法待优化。 贴一段第二个问题的代码：1234567891011121314151617181920212223242526- (NSMutableSet *)findSetWithMinEdge:(CGFloat)minEdge &#123; NSArray *ascendingEdgeArray = [self.allRects sortedArrayUsingComparator:^NSComparisonResult(LSVRectModel *obj1, LSVRectModel *obj2) &#123; return CGRectGetMinY(obj1.absRect) &gt; CGRectGetMinY(obj2.absRect) ? NSOrderedDescending : NSOrderedAscending; &#125;]; // TOOD: 此处待优化 // 二分法 NSInteger minIndex = 0; NSInteger maxIndex = ascendingEdgeArray.count - 1; NSInteger midIndex = (minIndex + maxIndex) / 2; LSVRectModel *model = ascendingEdgeArray[midIndex]; while (minIndex &lt; maxIndex - 1) &#123; if (CGRectGetMinY(model.absRect) &gt; minEdge) &#123; maxIndex = midIndex; &#125; else &#123; minIndex = midIndex; &#125; midIndex = (minIndex + maxIndex) / 2; model = ascendingEdgeArray[midIndex]; &#125; midIndex = MAX(midIndex - 1, 0); NSArray *array = [ascendingEdgeArray subarrayWithRange:NSMakeRange(midIndex, ascendingEdgeArray.count - midIndex)]; return [NSMutableSet setWithArray:array];&#125; 再贴一段第三个问题的代码：12345678910111213 NSMutableArray *newVisibleViews = [self visiableViewModels].mutableCopy; NSMutableArray *newVisibleLsvIds = [newVisibleViews valueForKey:@&quot;lsvId&quot;]; NSMutableArray *removeViews = [NSMutableArray array]; for (UIView *view in self.visibleViews) &#123; if (![newVisibleLsvIds containsObject:view.lsvId]) &#123; [removeViews addObject:view]; &#125; &#125; for (UIView *view in removeViews) &#123; [self.visibleViews removeObject:view]; [self enqueueReusableView:view]; [view removeFromSuperview]; &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>LazyScrollView</tag>
        <tag>高性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS创建单例]]></title>
    <url>%2F2016%2F11%2F01%2FiOS%E5%88%9B%E5%BB%BA%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[在开发过程中经常会遇到需要单例的时候，然后很多时候大家写的单例其实并不符合要求。下面介绍一个标准的单例。 一般来说，我还是喜欢用GCD来创建单例，使用dispatch_once很方便。12345678910static id _instance; + (instancetype)sharedInstance &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [[self alloc] init]; &#125;); return _instance; &#125; 上面说的并不符合要求就是这样创建出来的单例。很多人以为这样就可以了，dispatch_once保证了只运行一次。然而，如果一个不知情的人调用了你写的类，你无法保证他不去调用alloc，copy来生成实例。所以我们还要做一些其他的处理。 1234567891011121314151617+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [super allocWithZone:zone]; &#125;); return _instance; &#125; - (id)copyWithZone:(NSZone *)zone &#123; return _instance; &#125; - (id)mutableCopyWithZone:(NSZone *)zone &#123; return _instance; &#125; 这样就可以了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS10下使用AutoLayout动画失效解决]]></title>
    <url>%2F2016%2F11%2F01%2FiOS10%E4%B8%8B%E4%BD%BF%E7%94%A8AutoLayout%E5%8A%A8%E7%94%BB%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[更新到 iOS10 后，原来使用 AutoLayout 自定义的控件做了一些简单的动画失效了，但是在 iOS10 以下还是正常的。于是 Google 了一番，终于又是在 http://stackoverflow.com 找到了解决办法。 123456789101112[UIView animateWithDuration:0.3 delay:0 options:UIViewAnimationOptionCurveEaseOut animations:^&#123; [self mas_updateConstraints:^(MASConstraintMaker *make) &#123; &#125;]; [self layoutIfNeeded]; &#125; completion:^(BOOL finished) &#123; &#125;]; 原来我们的代码应该是类似这样的，使用 layoutIfNeeded 强制刷新然后执行动画。iOS10 以后需要使用 [self.superview layoutIfNeeded]; 。这样消失的动画就又出来了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
        <tag>iOS10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode多Target设置]]></title>
    <url>%2F2016%2F10%2F01%2FXcode%E5%A4%9ATarget%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[有时候一个项目会分为多个版本，比如免费版、收费版，或者对于不同的客户定制不同版本。但是大体上功能都是差不多，只是部分页面稍有区别。如果每个版本都建一个工程又显得麻烦了，都放在一个 Target 又得写一堆的代码去区分甄别，而且在打包的时候很可能因为参数配置错误需要一而再、再而三的打包。 这个时候我们就可以用多 Target 来操作了。具体方法且听我一一道来。 * 首先我们得有一个工程，这里我就新建一个基本的模板工程。工程的样子应该是这样。（我已经升级到 Xcode8 了，有什么不同之处请不要在意。） * 然后我们进入工程设置，右击中间的 TARGETS ，会有个选择让你 Duplicate 还是 Delete ，这里我们选择 Duplicate。 结果就是下面这个样子了，多个一个 Target 叫 MultiTarget copy ，还多了一个 plist 文件叫 MultiTarget copy-Info.plist。 * 接下来首先想到的应该是改名字，毕竟 XXX copy 不怎么友好。目前我所知道的方法只有一个一个的改。 囧。 如果你有好的方法，可以留言给我。 改完 plist 的名字后，需要在工程设置里面重新选择一下 Info.plist 。改完之后就像下图一样。我列了一下我改的几个地方。但是我记得早期版本的 Xcode 好像还需要修改 Build Settings 里面的一些东西。不过我的 Xcode8 好像不需要了。大家在做的时候注意一下。 PS：忘了修改Bundle Identifier了，大家记得改一下 * 最后一步就是做版本区分了。首先我们在 PRO 版本中定义一个宏 PRO_VERSION，写在 Build Settings 里面。一定记得先选择 PRO Target。这个作用就是告诉编译器，我们在编译该 Target 时会有个全局的宏叫做 PRO_VERSION。这个时候我们就可以利用这个宏来做一些代码区分了。 * 最后我们测试一下。我们在 ViewController 里面增加一个 UILabel ，方便起见，我就直接写 frame 了，在两个不同版本显示不同的文本。代码如下。 123456789 UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 50, CGRectGetWidth([UIScreen mainScreen].bounds), 80)]; label.textAlignment = NSTextAlignmentCenter; [self.view addSubview:label]; #ifdef PRO_VERSION label.text = @&quot;这是PRO版本&quot;;#else label.text = @&quot;这是NORMAL版本&quot;;#endif 当然，编译哪个版本需要选择对应的 Scheme。下面放两张截图。 * 还有个事情就是图标，其实也可以设置的。打开 Assets.xcassets，会发现已经有一个 AppIcon 了，我们再copy一份出来，然后改个名字，换一下图标，就是这样的效果。 当然并没有结束，因为我们只是添加了资源，并没有用到。还是在工程设置里面，有个 App Icons Source ，选择一下就可以了。当然，我们还可以配置启动画面等等，这里就不演示了。 最后放一张两个 App 的图标，注意修改 Bundle Identifier，不然你不会运行出两个 App 的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>多Target</tag>
        <tag>多版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg解码流程]]></title>
    <url>%2F2016%2F09%2F30%2FFFmpeg%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[以下系列文章基于FFmpeg 3.1.1和Xcode8。FFmpeg iOS库编译与集成FFmpeg解码流程 学习 FFmpeg ，就不得不提到一位大神，就是 雷霄骅，可惜天妒英才，在这里也先缅怀一下，同时也感谢他在视音频领域以及 FFmpeg 解析上做出的贡献。 我们先了解一下视频播放的流程，这里主要参考的是雷神的文章，[总结]视音频编解码技术零基础学习方法 。过程见下图（图片同样来自雷神的文章，红色框框是我注解的）。 播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。 关于每个步骤的含义还是去雷神的文章去看，这里就不啰嗦了。 本文重点讨论的是解封装、解码视频。对于音频的处理先不管。 解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。 好了，说了这么多理论，说点实在的。 FFmpeg 解码流程所需要调用的 API 依次为： 123456789101112开始—-&gt;av_register_all();avformat_open_input()；av_find_stream_info();av_find_best_stream();avcodec_find_decoder();while(av_read_frame()) &#123; 获取到packet—-&gt; avcodec_send_packet(); avcodec_receive_frame(); 获取到frame&#125; 上面的流程参考 笔谈FFmpeg（一），其中有几个函数弃用了，所以我更新了一下。 简单的说一下更新的几个函数，其他的网上介绍的很多了，后面我也会推荐几篇文章。 av_find_best_stream()： 之前用的都是这样的方法： 穷举所有的流，查找其中种类为CODEC_TYPE_VIDEO 。所以看别人的文章会有个 while 的循环。 avcodec_send_packet();avcodec_receive_frame();： 之前用的是 avcodec_decode_video2() 。后来 FFmpeg 把函数拆分了。 还有个需要注意的，avcodec_find_decoder(); 步骤中所用到的也有所变动。下面是以前的用法： 12pCodecCtx = pFormatCtx-&gt;streams[videoindex]-&gt;codec; pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); 下面是变动之后的用法： 123pCodecCtx = avcodec_alloc_context3(NULL);avcodec_parameters_to_context(pCodecCtx, pFormatCtx-&gt;streams[videoStream]-&gt;codecpar);pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); 通过以上的步骤，获取到 frame 数据就是解码后的原始视频数据。后面我们的存储或者播放也都是基于这个数据的。 参考文章列表： 100行代码实现最简单的基于FFMPEG+SDL的视频播放器（SDL1.x） 作者：雷霄骅 笔谈FFmpeg（一） 作者：Minmin.Sun ffmpeg解码流程 作者：cyning4星运]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg iOS库编译与集成]]></title>
    <url>%2F2016%2F09%2F26%2FFFmpeg%20iOS%E5%BA%93%E7%BC%96%E8%AF%91%E4%B8%8E%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[以下系列文章基于FFmpeg 3.1.1和Xcode8。FFmpeg iOS库编译与集成FFmpeg解码流程由于FFmpeg工程太大，很难一下子理解透彻，所以就边看边记一些笔记，理清一下思路，顺便也留给其他人一些意见。 1. 下载FFmpeg的源码编译iOS库。而编译FFmpeg还需要另外两项的支持 https://github.com/libav/gas-preprocessor yasm 这样就比较复杂，如果想自己一步一步的按照流程来做，可以参考这篇文章 iOS配置FFmpeg框架(原创) 。 所以 Github 上有个开源的脚本，https://github.com/kewlbear/FFmpeg-iOS-build-script ，下载之后，直接 ./build-ffmpeg.sh，脚本会自动帮你下载相关文件以及配置。 编译成功之后，就会在文件夹里面看到 FFmpeg-iOS 的文件夹，里面就是静态库，还有个 ffmpeg-3.1.1 的文件夹，就是源码。当然，如果你熟悉脚本语言可以看一下里面的脚本，可以修改一些配置，达到你想要的结果。这里暂时先不展开了。 2. 集成静态库至Xcode 新建工程。 新建一个 Single View Application ，然后将 FFmpeg-iOS 文件夹拖进工程。然后需要在 Build Setting 里面配置一下 Header Search Paths ，需要将 include 以及 include 下面的子文件夹都配置进去。 添加依赖库。 需要添加以下几个 framework 和 lib ： CoreMedia.framework ， VideoToolbox.framework ， AudioToolbox.framework ， libiconv.2.4.0.tbd ， libbz2.1.0.tbd ， libz.1.2.5.tbd。 编译 在 ViewController 里包含头文件 #import &quot;avcodec.h&quot;， 然后在 viewDidLoad 中调用 avcodec_register_all(); ，应该就可以编译通过了。 在我的 Xcode8 中会有一堆警告，提示 empty paragraph passed to @param command ，这里我们需要处理一下。在引用头文件的时候使用宏包含一下。 123456#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdocumentation&quot;#import &quot;avcodec.h&quot;#pragma clang pop 至此，FFmpeg 就集成完毕了。]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Podfile引用第三方库设定版本]]></title>
    <url>%2F2015%2F09%2F25%2FPodfile%E5%BC%95%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%AE%BE%E5%AE%9A%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[在使用cocoapods引用第三方库时，可以使用如下规则规定引用三方库的版本。 123456789pod &apos;AFNetworking’ // 不显式指定依赖库版本，表示每次都获取最新版本pod &apos;AFNetworking’, &apos;2.0’ //只使用2.0版本pod &apos;AFNetworking’, &apos;&gt;2.0&apos; //使用高于2.0的版本pod &apos;AFNetworking’, &apos;&gt;=2.0&apos; //使用大于或等于2.0的版本pod &apos;AFNetworking’, &apos;&lt;2.0&apos; //使用小于2.0的版本pod &apos;AFNetworking’, &apos;&lt;=2.0&apos; //使用小于或等于2.0的版本pod &apos;AFNetworking’, &apos;~&gt;0.1.2&apos; //使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0pod &apos;AFNetworking’, &apos;~&gt;0.1&apos; //使用大于等于0.1但小于1.0的版本pod &apos;AFNetworking’, &apos;~&gt;0&apos; //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GeoHash系列 —— 二、算法步骤]]></title>
    <url>%2F2015%2F08%2F27%2FGeoHash%E7%B3%BB%E5%88%97%20%E2%80%94%E2%80%94%20%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[系列文章 GeoHash系列 —— 一、基本介绍 GeoHash系列 —— 二、算法步骤 上集回顾上一篇文章我们简单了了解了一下GeoHash的思想，你可以通过这个链接来查看上一篇文章。 算法步骤以下以北海公园为例介绍GeoHash算法的计算步骤。 根据经纬度计算GeoHash二进制编码 地球纬度区间是[-90,90]， 北海公园的纬度是39.928167，可以通过下面算法对纬度39.928167进行逼近编码: 1）区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1； 2）接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0； 3）递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167； 4）如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，这样随着算法的进行会产生一个序列1011100，序列的长度跟给定的区间划分次数有关。 根据纬度算编码 bit min mid max 1 -90.000 0.000 90.000 0 0.000 45.000 90.000 1 0.000 22.500 45.000 1 22.500 33.750 45.000 1 33.7500 39.375 45.000 0 39.375 42.188 45.000 0 39.375 40.7815 42.188 0 39.375 40.07825 40.7815 1 39.375 39.726625 40.07825 1 39.726625 39.9024375 40.07825 同理，地球经度区间是[-180,180]，可以对经度116.389550进行编码。 bit min mid max 1 -180 0.000 180 1 0.000 90 180 0 90 135 180 1 90 112.5 135 0 112.5 123.75 135 0 112.5 118.125 123.75 1 112.5 115.3125 118.125 0 115.3125 116.71875 118.125 1 115.3125 116.015625 116.71875 1 116.015625 116.3671875 116.71875 组码 通过上述计算，纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。 最后使用用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，首先将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。同理，将编码转换成经纬度的解码算法与之相反，具体不再赘述。 编码长度与精度下表摘自维基百科：http://en.wikipedia.org/wiki/Geohash 以看出，当geohash base32编码长度为8时，精度在19米左右，而当编码长度为9时，精度在2米左右，编码长度需要根据数据情况进行选择。 下集预告本篇主要说了一下将经纬度转化为字符串编码，下一节将解释一下上述做法的原理。]]></content>
      <categories>
        <category>Geohash系列</category>
      </categories>
      <tags>
        <tag>Geohash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GeoHash系列 —— 一、基本介绍]]></title>
    <url>%2F2015%2F08%2F26%2FGeoHash%E7%B3%BB%E5%88%97%20%E2%80%94%E2%80%94%20%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[系列文章 GeoHash系列 —— 一、基本介绍 GeoHash系列 —— 二、算法步骤 引子目前很多的App都会使用到用户的地理位置信息，然后为用户提供相关服务，也就是我们所说的LBS。而LBS最基本的就是附近。所以就会有这样的一个问题： 什么样叫附近？ 简单来说，附件就是以我为圆心，radius为半径画一个圆，圆内的都叫附近。 然而事实并没有这么简单。比如我要在地图上找附近的餐馆，不可能说把所有的餐馆和我的距离都算一遍，然后和radius比较。 稍微有点编程基础的应该都不会用这个办法。 其实那么庞大的数据，只有一小部分是我们想要的，这样我们通过某种方法来过滤掉不要的餐馆，减少计算的量，就避免了上述方法的弊端。 这样我们可以使用索引技术。 一提到索引，大家脑子里马上浮现出B树索引，因为大量的数据库（如MySQL、oracle、PostgreSQL等）都在使用B树。B树索引本质上是对索引字段进行排序，然后通过类似二分查找的方法进行快速查找，即它要求索引的字段是可排序的，一般而言，可排序的是一维字段，比如时间、年龄、薪水等等。但是对于空间上的一个点（二维，包括经度和纬度），如何排序呢？又如何索引呢？解决的方法很多，下文介绍一种方法来解决这一问题。 思想：如果能通过某种方法将二维的点数据转换成一维的数据，那样不就可以继续使用B树索引了嘛。那这种方法真的存在嘛，答案是肯定的。目前很火的GeoHash算法就是运用了上述思想，下面我们就开始GeoHash之旅吧。 基本介绍 GeoHash将二维的经纬度转换成字符串，每个字符串代表某一矩形区域。这样，矩形内所有的点（经纬度）都共享相同的GeoHash字符串，这样就比较容易做缓存。例如下图展示了北京9个区域的GeoHash字符串。例如左上角这个区域内的用户不断发送位置信息请求餐馆数据，由于这些用户的GeoHash字符串都是WX4ER，所以可以把WX4ER当作key，把该区域的餐馆信息当作value来进行缓存，而如果不使用GeoHash的话，由于区域内的用户传来的经纬度是各不相同的，很难做缓存。 字符串越长，表示的范围越精确。5位的编码能表示10平方千米范围的矩形区域，而6位编码能表示更精细的区域（约0.34平方千米）。 字符串相似的表示距离相近（特殊情况后文阐述），这样可以利用字符串的前缀匹配来查询附近的POI信息。如下两个图所示，一个在城区，一个在郊区，城区的GeoHash字符串之间比较相似，郊区的字符串之间也比较相似，而城区和郊区的GeoHash字符串相似程度要低些。 通过上面的介绍我们知道了GeoHash就是一种将经纬度转换成字符串的方法，并且使得在大部分情况下，字符串前缀匹配越多的距离越近，回到我们的案例，根据所在位置查询来查询附近餐馆时，只需要将所在位置经纬度转换成GeoHash字符串，并与各个餐馆的GeoHash字符串进行前缀匹配，匹配越多的距离越近。 下集预告GeoHash算法的步骤]]></content>
      <categories>
        <category>Geohash系列</category>
      </categories>
      <tags>
        <tag>Geohash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView点击StatusBar返回顶部失效的解决]]></title>
    <url>%2F2015%2F08%2F21%2FUIScrollView%E7%82%B9%E5%87%BBStatusBar%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前几天看到一篇文章，关于如何解决在一个Vieww中有多个UIScrollView或者UIScrollView子类时，点击StatusBar无法使UIScrollView返回到顶部的文章。总得思想是自定义一个View，然后覆盖在StatusBar上，给这个View添加点击事件。具体文章链接在这里。有兴趣的朋友可以看一下。其实我们查看UIScrollView的头文件就可以找到这段注释： 123// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.// On iPhone, we execute this gesture only if there&apos;s one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled.@property(nonatomic) BOOL scrollsToTop; // default is YES. 这样我们就可以很清楚的了解到，scrollsToTop的默认值是YES，然而当有多个UIScrollView的时候，用户点击StatusBar，系统就不知道让哪一个UIScrollView来执行scrollsToTop这个动作了，所以就导致失效了。 这样一来，解决方法就很简单了，设置你想要执行scrollsToTop的UIScrollView的@property(nonatomic) BOOL scrollsToTop;属性值为YES，其他的UIScrollView都为NO即可。 注意：凡是UIScrollView以及UIScrollView的子类都要设置。如:UITableView，UIWebView，UICollectionView等。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[房贷个税一个都不能少]]></title>
    <url>%2F2015%2F06%2F12%2F%E6%88%BF%E8%B4%B7%E4%B8%AA%E7%A8%8E%E4%B8%80%E4%B8%AA%E9%83%BD%E4%B8%8D%E8%83%BD%E5%B0%91%2F</url>
    <content type="text"><![CDATA[打个广告最近趁着稍闲,做了个APP,计算房贷和个税的.也不知道起个啥名字,暂时就叫 综合计算器. 刚刚送上线.话说苹果审核真麻烦.又拖了我2个星期. 如果有需要的话可以支持一下哦~当初做的时候也是处于懒得装两个APP,毕竟一个小功能,于是就有了这个综合版,顺便赚点外快. 再来个二维码 ps: 1.如果你有好的命名可以发邮件给我哦~ 2.如果你想做安卓版也可以发邮件给我哦~ 3.如果你有其他想法也可以发邮件给我哦~ 下面是我的邮箱: history_zq@163.com]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[App内打开AppStore]]></title>
    <url>%2F2015%2F05%2F19%2FApp%E5%86%85%E6%89%93%E5%BC%80AppStore%2F</url>
    <content type="text"><![CDATA[iOS7以后可以在应用内打开AppStore展示另一个App.这样就可以直接下载了. 我们只要使用这段代码就可以了. 应用库文件 我们可以这样引用: @import StoreKit; 请求App 12345678910SKStoreProductViewController *storeProductVc = [[SKStoreProductViewController alloc] init]; storeProductVc.delegate = self; [storeProductVc loadProductWithParameters:@&#123; SKStoreProductParameterITunesItemIdentifier: @&quot;XXXXXXX&quot;, &#125; completionBlock:^(BOOL result, NSError *error) &#123; if (result) &#123; [self presentViewController:storeProductVc animated:YES completion:nil]; &#125; &#125;]; 实现delegate dismiss SKStoreProductViewController 1234- (void)productViewControllerDidFinish:(SKStoreProductViewController *)viewController&#123; [viewController dismissViewControllerAnimated:YES completion:nil];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AppStore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS8下TabBarController push后控件下移闪动]]></title>
    <url>%2F2015%2F04%2F27%2FiOS8%E4%B8%8BTabBarController%20push%E5%90%8E%E6%8E%A7%E4%BB%B6%E4%B8%8B%E7%A7%BB%E9%97%AA%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[使用TabBarController后,如果push下一个页面需要隐藏TabBar,而下一个页面中有个控件设置AutoLayout的时候设置了和页面底部的距离,那么会有个闪烁动画,控件会以动画的形式下移44px.该现象只在iOS8中有,iOS7未发现. 我们需要在设置AutoLayout的时候如下图修改一下即可修复这个动画.]]></content>
      <tags>
        <tag>iOS随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS汉字转拼音]]></title>
    <url>%2F2014%2F12%2F12%2FiOS%E6%B1%89%E5%AD%97%E8%BD%AC%E6%8B%BC%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[汉字转拼音之前有很多人用的都是一个拼音库,pinyin.h和pinyin.m.用着还算方便吧. 后来发现苹果的framework提供了方法.于是在这里记录下来. 主要是用到这个方法:CFStringTransform.具体大家可以去头文件看看.这里就贴出代码了. - (NSString *)spelling { if (self.length) { NSMutableString *copy = [self mutableCopy]; CFStringTransform((__bridge CFMutableStringRef)copy, NULL, kCFStringTransformMandarinLatin, NO); // 得到带音调的拼音 CFStringTransform((__bridge CFMutableStringRef)copy, NULL, kCFStringTransformStripDiacritics, NO); // 过滤掉音调 每个汉字之间会用空格分开 [copy replaceOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot; options:NSCaseInsensitiveSearch range:NSMakeRange(0, copy.length)]; // 过滤掉空格 return copy; } else { return nil; } } 偷偷告诉大家一个神奇的事情,就是这个方法可以准确识别出重庆和重量.其他待测试.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>拼音</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView多余分割线]]></title>
    <url>%2F2014%2F12%2F04%2FUITableView%E5%A4%9A%E4%BD%99%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[UITableView会有多余的分割线,不论是否有内容都会显示出来,看着很心塞.于是这样: 设置UITableView的style为Group 实现以下DataSource 123456789- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123; return 0.01f;&#125; - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; return 0.01f;&#125; 整个世界安静了.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS拨打电话]]></title>
    <url>%2F2014%2F09%2F05%2FiOS%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[iOS拨打电话公开的方法有两种,其他的是调用私有方法,是会被苹果拒绝的.下面记录一下. 第一种方法拨打完之后会停留在拨号盘,不会返回应用。 1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;tel://123456789&quot;]]; 第二种方法拨打玩电话后会返回应用，但是拨打之前会有一个UIAlertView提示是否拨打。 1234UIWebView *callWebview =[[UIWebView alloc] init]; // 如果无效,则将callWebView置为成员变量NSURL *telURL =[NSURL URLWithString:@&quot;tel:10086&quot;];[callWebview loadRequest:[NSURLRequest requestWithURL:telURL]];[self.view addSubview:callWebview];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>电话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime在Storyboard中的应用]]></title>
    <url>%2F2014%2F09%2F01%2FRuntime%E5%9C%A8Storyboard%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[正文Runtime真是无处不在啊,打开Storyboard后,我们添加一个View到界面中,选中View,切换属性卡到第三个,有一项是 User Defined Runtime Attributes,我们添加如下图两个Key Path并设置值. 然后运行,果然可以看到我们设置的属性生效了.顿感强大.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode自动打包ipa脚本]]></title>
    <url>%2F2014%2F08%2F11%2FXCode%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85ipa%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[首先申明转载:http://webfrogs.me/2012/09/19/buildipa/. iOS打包我们可以借助shell脚本来自动完成这项功能.具体做法如下: 复制下面代码到文本中并保存为ipa_build.sh. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/bin/bash#--------------------------------------------# 功能：为Xcode工程打ipa包# 作者：ccf# E-mail:ccf.developer@gmail.com# 创建日期：2012/09/24#--------------------------------------------#参数判断if [ $# != 2 ] &amp;&amp; [ $# != 1 ];then echo &quot;Number of params error! Need one or two params!&quot; echo &quot;1.path of project(necessary) 2.name of ipa file(optional)&quot; exit elif [ ! -d $1 ];then echo &quot;Params Error!! The first param must be a dictionary.&quot; exit fi#工程绝对路径cd $1project_path=$(pwd)#build文件夹路径build_path=$&#123;project_path&#125;/build#工程配置文件路径project_name=$(ls | grep xcodeproj | awk -F.xcodeproj &apos;&#123;print $1&#125;&apos;)project_infoplist_path=$&#123;project_path&#125;/$&#123;project_name&#125;/$&#123;project_name&#125;-Info.plist#取版本号bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; $&#123;project_infoplist_path&#125;)#取build值bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; $&#123;project_infoplist_path&#125;)#取bundle Identifier前缀#bundlePrefix=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleIdentifier&quot; `find . -name &quot;*-Info.plist&quot;` | awk -F$ &apos;&#123;print $1&#125;&apos;)#IPA名称if [ $# = 2 ];thenipa_name=$2fi#编译工程cd $project_pathxcodebuild || exit#打包cd $build_pathtarget_name=$(basename ./Release-iphoneos/*.app | awk -F. &apos;&#123;print $1&#125;&apos;)if [ $# = 1 ];thenipa_name=&quot;$&#123;target_name&#125;_$&#123;bundleShortVersion&#125;_build$&#123;bundleVersion&#125;_$(date +&quot;%Y%m%d&quot;)&quot;fiif [ -d ./ipa-build ];then rm -rf ipa-buildfimkdir -p ipa-build/Payloadcp -r ./Release-iphoneos/*.app ./ipa-build/Payload/cd ipa-buildzip -r $&#123;ipa_name&#125;.ipa *rm -rf Payload 为文件添加可执行权限,命令如下: 1chmod +x ipa_build.sh 使用如下命令开始打包. 1./ipa_build ....../ProjectDir Project 其中的两个参数分别为:项目路径和最终打包的ipa名. 执行完命令后会在ProjectDir文件夹下生成build文件夹,ipa文件就在build下的ipa-build文件夹中.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>自动打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2d v3.x mac 安装]]></title>
    <url>%2F2014%2F08%2F08%2Fcocos2d%20v3.x%20mac%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[cocos2d v3.x 版本出来后,从配置安装到创建项目都是命令行,下面简单说一下. 官网下载最新版本Cocos2d-x,地址是 http://cn.cocos2d-x.org/download/. 解压后,在命令行中cp到文件夹,然后执行./setup.py,回车. 期间会有几次询问,是设置安卓SDK路径的,不设置安卓直接Enter跳过即可 123-&gt;Please enter the path of NDK_ROOT (or press Enter to skip):-&gt;Please enter the path of ANDROID_SDK_ROOT (or press Enter to skip):-&gt;Please enter the path of ANT_ROOT (or press Enter to skip): 之后就OK了,会有提示:1Please execute command: &quot;source /Users/history/.bash_profile&quot; to make added system variables take effect 根据提示敲击source /Users/history/.bash_profile后Enter,这样就算设置好了. 最后就是创建工程.继续命令行.cd tools/cocos2d-console/bin,接着使用下面命令即可:cocos new 工程名 -p 包名 -l 语言 -d 目标文件夹,例如./cocos new HelloWorld -p com.history.HelloWorld -l cpp -d ~/Wrok/Projects/Privates/.执行后就有如下提示: 123456Running command: new&gt; Copy template into /Users/history/Wrok/Projects/Privates/HelloWorld&gt; Copying cocos2d-x files...&gt; Rename project name from &apos;HelloCpp&apos; to &apos;HelloWorld&apos;&gt; Replace the project name from &apos;HelloCpp&apos; to &apos;HelloWorld&apos;&gt; Replace the project package name from &apos;org.cocos2dx.hellocpp&apos; to &apos;com.history.HelloWorld&apos; 这样就大功告成了.]]></content>
      <categories>
        <category>cocos2d-x</category>
      </categories>
      <tags>
        <tag>cocos2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客分页和阅读更多功能]]></title>
    <url>%2F2014%2F08%2F06%2F%E5%8D%9A%E5%AE%A2%E5%88%86%E9%A1%B5%E5%92%8C%E9%98%85%E8%AF%BB%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[博客也写了几篇了,一页显示有点长,于是就着手分页功能.顺便设置一下”继续阅读”的功能. 分页 找到source/index.html文件,找到这段代码: 修改为: 继续阅读 打开_config.yml文件,找到excerpt_link字段,你可以修改为自己想要显示的文字,”继续阅读”或者”Read More”等.注意到excerpt_separator这个字段,内容是&lt;!--more--&gt;,这个就是告诉你在写文章的时候,在你想要显示为”继续阅读”的地方添加上&lt;!--more--&gt;即可.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS配置gitignore文件]]></title>
    <url>%2F2014%2F08%2F04%2FiOS%E9%85%8D%E7%BD%AEgitignore%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[iOS开发中如果使用Git来管理源代码,很多文件是不需要上传到服务器的,这时候我们就需要配置.gitignore文件.具体做法是: 123456789101112131415161718192021# Xcode.DS_Store*/build/**.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdataprofile*.moved-asideDerivedData.idea/*.hmap*.orig# CocoaPodsPods 拷贝上述代码到记事本中,然后保存到你的项目根目录下,文件名为.gitignore.注意,不要有.txt等后缀.该文件是隐藏的,如果需要显示Mac隐藏文件,如下命令即可: 1defaults write com.apple.finder AppleShowAllFiles -bool true 输完单击Enter键，退出终端，重新启动Finder就可以了 重启Finder：按住option,鼠标左击dock上的Finder图标不松,直到出现菜单后点击重新开启即可. 顺便附上隐藏Mac隐藏文件命令: 1defaults write com.apple.finder AppleShowAllFiles -bool false]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS提交AppStore时描述翻译]]></title>
    <url>%2F2014%2F08%2F04%2FiOS%E6%8F%90%E4%BA%A4AppStore%E6%97%B6%E6%8F%8F%E8%BF%B0%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[提交AppStore时有很多选项,不过都是英文的.这里收集一下,以备查阅. AppleContent Descriptions None Infrequent/Mild 苹果内容描述 不存在 频繁或强烈的 选项 翻译 Cartoon or Fantasy Violence 卡通或幻想暴力 Realistic Violence 现实暴力 Sexual Content or Nudity 性爱或裸体内容 Profanity or Crude Humor 亵渎或低俗笑话 Alcohol, Tobacco, or Drug Use or References 研究或毒品相关内容 Mature/Suggestive Themes 成人或性暗示主题 Simulated Gambling 模拟赌博 Horror/Fear Themes 恐怖/惊悚题材 Prolonged graphic or sadistic realistic violence 持久直白或虐待狂现实暴力 Graphic sexual content and nudity 直白的色情和裸色内容 ps:以上内容转自 唯高的博客 中发布iOS有用到苹果商店时选择应用分级的中文翻译.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AppStore</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS合并真机和模拟器静态库]]></title>
    <url>%2F2014%2F08%2F03%2FiOS%E5%90%88%E5%B9%B6%E7%9C%9F%E6%9C%BA%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前言有时候会在真机和模拟器间切换,总是来回替换库到是很不方便.这样可以在开发的时候将真机和模拟器库何必为一个文件,等到发布的时候再替换为真机库即可. 正文使用下面的命令即可合并两个静态库. 1lipo -create /libXXSimulator.a /libXXOs.a -output /libXX.a 使用的时候记得注意文件的路径.其中-create后的两个参数是真机和模拟器静态库的路径,-output后面的参数是合并后的静态库路径.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hidesBottomBarWhenPushed用法]]></title>
    <url>%2F2014%2F08%2F02%2FhidesBottomBarWhenPushed%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言前两天看论坛又看到有人在问hidesBottomBarWhenPushed到底怎么用,为什么他用总是不对.所以在这里还是总结下,希望可以帮助更多的人. 正文在使用TabBar的时候,需要在push到下个页面的时候隐藏TabBar,再pop回来的时候显示TabBar.以前有很多博客是说使用hidden参数,不过总是有黑边,遂又有一堆博客解决如何去掉黑边,甚至有人自定义了TabBar. 其实看看API就会发现有hidesBottomBarWhenPushed这个属性可以使用.不过很多人用了发现有点问题,比如有A-&gt;B-&gt;C这个push流程,其中A中有TabBar,B和C中需要隐藏,很多人从A push到 B是可以隐藏TabBar,可是B push到 C又冒出来了.或者从C pop到 B又冒出来了.反正就是不对. 说到底,还是用法有误.Apple不会给一个错误的API的.其实你可以在B和C的init函数中使用self.hidesBottomBarWhenPushed = YES,这样就可以达到你想要的效果了.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>TabBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub博客访问超慢解决]]></title>
    <url>%2F2014%2F08%2F01%2FGitHub%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E8%B6%85%E6%85%A2%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[越来越发现博客访问速度超慢了,看了几篇博客说是google的问题,就把所有关于google的东西都删了,还是很慢.也参照过唐巧的技术博客象写程序一样写博客：搭建基于github的博客中: 主要是修改文件：_config.yml ，这个配置文件都有相应的注释。主要就是改一些博客头，作者名之类的东西。 注意最好把里面的twitter相关的信息全部删掉，否则由于GFW的原因，将会造成页面load很慢。 修改定制文件/source/_includes/custom/head.html 把google的自定义字体去掉，原因同上。 可是发现还是很慢.最终测试发现每次加载其实是由于在加载汉字时很慢,加载英文,图片和数字倒是很快,再参考网上所说还是觉得使用了google的字体.所以决定还是找个博客看一下他们的字体是怎么设置的. 于是进入了码农人生的GitHub主页,然后进入source分支,找到msching.github.io / source / _includes / head.html这个文件,打开后和我的文件对比,发现他主要修改了这里: &lt;!--[good job! gfw]&gt;&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!--&gt; &lt;script src=&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;/stylesheets/google-fonts.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; 还写上了注释,于是无耻的偷了过来,不过要注意,第三行中的.css文件是本地的引用,在/stylesheets/google-fonts.css中,于是来到msching.github.io / source / stylesheets / google-fonts.css这里,拷贝下文件内容新建并保存到同样的目录下. 大功告成,上传后试了下,果然速度大幅度提升.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆形头像]]></title>
    <url>%2F2014%2F07%2F29%2F%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[看过很多圆形头像的APP了.比如最近QQ又更新了,头像都变成圆形的了.其实在iOS实现这个很简单,几句代码即可.下面还是贴出来以便查阅.12345[imageView.layer setCornerRadius:CGRectGetHeight(imageView.bounds) / 2];imageView.layer.masksToBounds = YES;// 下面两句是设置圆周的线条颜色,可以根据实际情况选择imageView.layer.borderWidth = 3.f;imageView.layer.borderColor = [[UIColor whiteColor] CGColor]; 最后上一张图吧.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>圆形头像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引入三方库编译错误解决]]></title>
    <url>%2F2014%2F07%2F27%2F%E5%BC%95%E5%85%A5%E4%B8%89%E6%96%B9%E5%BA%93%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言Coding中不免要引入三方库,有时候会出现很多编译错误,在此收集一下. 正文1.如下错误可在Other Link Flags添加-licucore解决 12345678910111213141516171819202122232425262728293031323334353637Undefined symbols for architecture i386: &quot;_u_errorName&quot;, referenced from: _cm_rkl_NSExceptionForRegex in AGCommon _cm_rkl_userInfoDictionary in AGCommon &quot;_u_strlen&quot;, referenced from: _cm_rkl_userInfoDictionary in AGCommon &quot;_uregex_appendReplacement&quot;, referenced from: _cm_rkl_replaceAll in AGCommon &quot;_uregex_appendTail&quot;, referenced from: _cm_rkl_replaceAll in AGCommon &quot;_uregex_clone&quot;, referenced from: -[CMRKLBlockEnumerationHelper initWithRegex:options:string:range:error:] in AGCommon &quot;_uregex_close&quot;, referenced from: _cm_rkl_clearCachedRegex in AGCommon &quot;_uregex_end&quot;, referenced from: _cm_rkl_performRegexOp in AGCommon _cm_rkl_findRanges in AGCommon _cm_rkl_search in AGCommon &quot;_uregex_find&quot;, referenced from: _cm_rkl_search in AGCommon &quot;_uregex_findNext&quot;, referenced from: _cm_rkl_search in AGCommon _cm_rkl_replaceAll in AGCommon &quot;_uregex_groupCount&quot;, referenced from: _cm_rkl_getCachedRegex in AGCommon &quot;_uregex_open&quot;, referenced from: _cm_rkl_getCachedRegex in AGCommon &quot;_uregex_reset&quot;, referenced from: _cm_rkl_replaceAll in AGCommon &quot;_uregex_setText&quot;, referenced from: -[CMRKLBlockEnumerationHelper initWithRegex:options:string:range:error:] in AGCommon _cm_rkl_performRegexOp in AGCommon _cm_rkl_clearCachedRegexSetTo in AGCommon &quot;_uregex_start&quot;, referenced from: _cm_rkl_performRegexOp in AGCommon _cm_rkl_findRanges in AGCommon _cm_rkl_search in AGCommon]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSArray对所有元素操作]]></title>
    <url>%2F2014%2F07%2F23%2FNSArray%E5%AF%B9%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[看别人的源码无意中看到一个方法,是NSArray的实例方法: 12- (void)makeObjectsPerformSelector:(SEL)aSelector;- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)argument; 用处是让NSArray中的每一个元素都执行aSelector方法,还可以带参数argument.体验如下: 1[[self.view subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)]; 再也不用for循环去删除每一个子view了.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoLayout的使用]]></title>
    <url>%2F2014%2F07%2F20%2FAutoLayout%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言iOS8快要发正式版了,iPhone6也要出新的尺寸了,如果你还没有用Storyboard和AutoLayout那将是一种痛苦. 正文自从iPhone出了不同分辨率的屏幕后,iOS开发者也渐渐开始有了android开发者的痛苦了.当然Apple也提供了新的技术来尽量让开发者没有那么费劲.所以就推出了AutoLayout的技术.由于只能支持到IOS6,所以还是有部分的APP没有使用.不过相信还是大势所趋的.如果你的App都是使用storyboard或者xib来构建的,直接使用可视化操作就可以很轻松的完成了.但是对于复杂的UI免不了使用coding.这时候你就需要手动的去写那么autolayout代码.虽然autolayout的代码也是比较易理解,但是还是不那么的方便.这里推荐大家一个开源库,封装的还可以.是UIView的一个Category.GitHub上的主页在这里. 平时用的多的API也就是设置宽高,设置和父窗口的相对位置以及设置和兄弟窗口的相对位置.如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** Centers the view in its superview. */- (NSArray *)autoCenterInSuperview;/** Aligns the view to the same axis of its superview. */- (NSLayoutConstraint *)autoAlignAxisToSuperviewAxis:(ALAxis)axis;# pragma mark Pin Edges to Superview/** Pins the given edge of the view to the same edge of the superview with an inset. */- (NSLayoutConstraint *)autoPinEdgeToSuperviewEdge:(ALEdge)edge withInset:(CGFloat)inset;/** Pins the edges of the view to the edges of its superview with the given edge insets. */- (NSArray *)autoPinEdgesToSuperviewEdgesWithInsets:(ALEdgeInsets)insets;/** Pins 3 of the 4 edges of the view to the edges of its superview with the given edge insets, excluding one edge. */- (NSArray *)autoPinEdgesToSuperviewEdgesWithInsets:(ALEdgeInsets)insets excludingEdge:(ALEdge)edge;# pragma mark Pin Edges/** Pins an edge of the view to a given edge of another view. */- (NSLayoutConstraint *)autoPinEdge:(ALEdge)edge toEdge:(ALEdge)toEdge ofView:(ALView *)peerView;/** Pins an edge of the view to a given edge of another view with an offset. */- (NSLayoutConstraint *)autoPinEdge:(ALEdge)edge toEdge:(ALEdge)toEdge ofView:(ALView *)peerView withOffset:(CGFloat)offset; # pragma mark Align Axes/** Aligns an axis of the view to the same axis of another view. */- (NSLayoutConstraint *)autoAlignAxis:(ALAxis)axis toSameAxisOfView:(ALView *)peerView;/** Aligns an axis of the view to the same axis of another view with an offset. */- (NSLayoutConstraint *)autoAlignAxis:(ALAxis)axis toSameAxisOfView:(ALView *)peerView withOffset:(CGFloat)offset;# pragma mark Match Dimensions/** Matches a dimension of the view to a given dimension of another view. */- (NSLayoutConstraint *)autoMatchDimension:(ALDimension)dimension toDimension:(ALDimension)toDimension ofView:(ALView *)peerView;/** Matches a dimension of the view to a given dimension of another view with an offset. */- (NSLayoutConstraint *)autoMatchDimension:(ALDimension)dimension toDimension:(ALDimension)toDimension ofView:(ALView *)peerView withOffset:(CGFloat)offset; # pragma mark Set Dimensions/** Sets the view to a specific size. */- (NSArray *)autoSetDimensionsToSize:(CGSize)size;/** Sets the given dimension of the view to a specific size. */- (NSLayoutConstraint *)autoSetDimension:(ALDimension)dimension toSize:(CGFloat)size; 还有其他如设置relationship的API,大家可自行查看GitHub上的主页.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS8</tag>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS唯一标志]]></title>
    <url>%2F2014%2F07%2F19%2FiOS%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97%2F</url>
    <content type="text"><![CDATA[背景由于iOS对于用户隐私的保护,使得在iOS下面想要拿到一个唯一的设备号是不怎么方便的.当然在IOS5,6中还是可以有那么一丝希望的,UUID,MAC地址等.可是后来,苹果彻底把所有的路都堵死了.瞬间大家都觉得没戏了. 新方案既然我写这个博客,说明还是有方法的.大家都知道在Mac OSX上有Keychain,可以保存用户的所有密码.其实在iOS上也有这个Keychain的,只不过没有像Mac OSX上面那样的App来管理罢了.所以,我们就可以借用这个Keychain来构造设备的唯一标志.至于iOS底层的库我就不多说了,直接推荐一个三方开源库,SSKeychain,大家可以去GitHub下载,也可以使用CocosPods来管理. API我们主要使用SSKeychain中的几个API. a.获取密码12+ (NSString *)passwordForService:(NSString *)serviceName account:(NSString *)account;+ (NSString *)passwordForService:(NSString *)serviceName account:(NSString *)account error:(NSError **)error; b.删除密码12+ (BOOL)deletePasswordForService:(NSString *)serviceName account:(NSString *)account;+ (BOOL)deletePasswordForService:(NSString *)serviceName account:(NSString *)account error:(NSError **)error; c.设置密码12+ (BOOL)setPassword:(NSString *)password forService:(NSString *)serviceName account:(NSString *)account;+ (BOOL)setPassword:(NSString *)password forService:(NSString *)serviceName account:(NSString *)account error:(NSError **)error; 当然,我们是需要一个唯一标志,所以就需要生成一个UUID,这样就可以用SSKeychain来设置密码为生成的UUID,具体操作如下: 1.创建一个NSString的Category生成UUID123456789@implementation NSString (Extension)+ (NSString *)stringForUUID&#123; CFUUIDRef uuidObj = CFUUIDCreate(nil); NSString *uuidString = (NSString *)CFBridgingRelease(CFUUIDCreateString(nil, uuidObj)); CFRelease(uuidObj); return uuidString;&#125;@end 2.创建一个HZKeychainManager1234567891011121314@implementation HZKeychainManager+ (NSString *)appUUID&#123; NSError *error = nil; NSString *uuid = [SSKeychain passwordForService:@&quot;com.company.app.service&quot; account:@&quot;com.company.app.account&quot; error:&amp;error]; // 获取 密码 if (!uuid.length) &#123; // 如果获取不到 则新保存一个 uuid = [NSString stringForUUID]; BOOL res = [SSKeychain setPassword:uuid forService:kDBServiceKey account:kDBAccountKey error:&amp;error]; if (!res) &#123; &#125; &#125; return uuid;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UDID</tag>
        <tag>唯一标志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安家GitHub]]></title>
    <url>%2F2014%2F07%2F19%2F%E5%AE%89%E5%AE%B6GitHub%2F</url>
    <content type="text"><![CDATA[前言终于在GitHub安家博客了,看了很多博客,对*.github.io特感兴趣,GitHub找了一圈也没发现人家开博客服务.正好前段时间又忙,没空理会,所以搁浅了.正好这段时间稍闲,简单看了一下,不明觉厉.仔细研究了下,原来还是代码托管.索性我也弄一个试一下.顺便也给自己的码农生活记录一下. 总结其实利用GitHub和Octopress搭建博客已经有很多人的博客都记录了.这里我就不重复了,还是把我参考的一些博客贴出来,也让大家少走一些弯路. 首先是码农人生的博客基于Github和Octopress搭建属于自己的博客,大体上都是参考他的.其次是唐巧的技术博客象写程序一样写博客：搭建基于github的博客和将博客从GitHub迁移到GitCafe.最后是markdown标记的使用,本人小菜,所以借助了其他软件Mou,用了一下,感觉还可以. 尾声好了,就这么多了.愿自己坚持下去.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
